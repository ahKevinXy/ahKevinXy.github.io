"use strict";(self.webpackChunkah_kevin_xy=self.webpackChunkah_kevin_xy||[]).push([[70999],{52776:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>u,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=t(74848),a=t(28453);const o={},u="router_group",s={id:"backend/go/gin/source/1.7.7/router_group",title:"router_group",description:"",source:"@site/docs/backend/go/gin/source/1.7.7/router_group.md",sourceDirName:"backend/go/gin/source/1.7.7",slug:"/backend/go/gin/source/1.7.7/router_group",permalink:"/docs/backend/go/gin/source/1.7.7/router_group",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"response_write",permalink:"/docs/backend/go/gin/source/1.7.7/reponse_writer"},next:{title:"tree",permalink:"/docs/backend/go/gin/source/1.7.7/tree"}},i={},l=[];function h(e){const n={code:"code",h1:"h1",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"router_group",children:"router_group"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n "net/http"\n "path"\n "regexp"\n "strings"\n)\n\n// IRouter defines all router handle interface includes single and group router.\ntype IRouter interface {\n IRoutes\n Group(string, ...HandlerFunc) *RouterGroup\n}\n\n// IRoutes defines all router handle interface.\ntype IRoutes interface {\n Use(...HandlerFunc) IRoutes\n\n Handle(string, string, ...HandlerFunc) IRoutes\n Any(string, ...HandlerFunc) IRoutes\n GET(string, ...HandlerFunc) IRoutes\n POST(string, ...HandlerFunc) IRoutes\n DELETE(string, ...HandlerFunc) IRoutes\n PATCH(string, ...HandlerFunc) IRoutes\n PUT(string, ...HandlerFunc) IRoutes\n OPTIONS(string, ...HandlerFunc) IRoutes\n HEAD(string, ...HandlerFunc) IRoutes\n\n StaticFile(string, string) IRoutes\n Static(string, string) IRoutes\n StaticFS(string, http.FileSystem) IRoutes\n}\n\n// RouterGroup is used internally to configure router, a RouterGroup is associated with\n// a prefix and an array of handlers (middleware).\ntype RouterGroup struct {\n Handlers HandlersChain\n basePath string\n engine   *Engine\n root     bool\n}\n\nvar _ IRouter = &RouterGroup{}\n\n// Use adds middleware to the group, see example code in GitHub.\nfunc (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes {\n group.Handlers = append(group.Handlers, middleware...)\n return group.returnObj()\n}\n\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.\n// For example, all the routes that use a common middleware for authorization could be grouped.\nfunc (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup {\n return &RouterGroup{\n  Handlers: group.combineHandlers(handlers),\n  basePath: group.calculateAbsolutePath(relativePath),\n  engine:   group.engine,\n }\n}\n\n// BasePath returns the base path of router group.\n// For example, if v := router.Group("/rest/n/v1/api"), v.BasePath() is "/rest/n/v1/api".\nfunc (group *RouterGroup) BasePath() string {\n return group.basePath\n}\n\nfunc (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {\n absolutePath := group.calculateAbsolutePath(relativePath)\n handlers = group.combineHandlers(handlers)\n group.engine.addRoute(httpMethod, absolutePath, handlers)\n return group.returnObj()\n}\n\n// Handle registers a new request handle and middleware with the given path and method.\n// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.\n// See the example code in GitHub.\n//\n// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut\n// functions can be used.\n//\n// This function is intended for bulk loading and to allow the usage of less\n// frequently used, non-standardized or custom methods (e.g. for internal\n// communication with a proxy).\nfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {\n if matches, err := regexp.MatchString("^[A-Z]+$", httpMethod); !matches || err != nil {\n  panic("http method " + httpMethod + " is not valid")\n }\n return group.handle(httpMethod, relativePath, handlers)\n}\n\n// POST is a shortcut for router.Handle("POST", path, handle).\nfunc (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPost, relativePath, handlers)\n}\n\n// GET is a shortcut for router.Handle("GET", path, handle).\nfunc (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodGet, relativePath, handlers)\n}\n\n// DELETE is a shortcut for router.Handle("DELETE", path, handle).\nfunc (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodDelete, relativePath, handlers)\n}\n\n// PATCH is a shortcut for router.Handle("PATCH", path, handle).\nfunc (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPatch, relativePath, handlers)\n}\n\n// PUT is a shortcut for router.Handle("PUT", path, handle).\nfunc (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPut, relativePath, handlers)\n}\n\n// OPTIONS is a shortcut for router.Handle("OPTIONS", path, handle).\nfunc (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodOptions, relativePath, handlers)\n}\n\n// HEAD is a shortcut for router.Handle("HEAD", path, handle).\nfunc (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodHead, relativePath, handlers)\n}\n\n// Any registers a route that matches all the HTTP methods.\n// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes {\n group.handle(http.MethodGet, relativePath, handlers)\n group.handle(http.MethodPost, relativePath, handlers)\n group.handle(http.MethodPut, relativePath, handlers)\n group.handle(http.MethodPatch, relativePath, handlers)\n group.handle(http.MethodHead, relativePath, handlers)\n group.handle(http.MethodOptions, relativePath, handlers)\n group.handle(http.MethodDelete, relativePath, handlers)\n group.handle(http.MethodConnect, relativePath, handlers)\n group.handle(http.MethodTrace, relativePath, handlers)\n return group.returnObj()\n}\n\n// StaticFile registers a single route in order to serve a single file of the local filesystem.\n// router.StaticFile("favicon.ico", "./resources/favicon.ico")\nfunc (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes {\n if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") {\n  panic("URL parameters can not be used when serving a static file")\n }\n handler := func(c *Context) {\n  c.File(filepath)\n }\n group.GET(relativePath, handler)\n group.HEAD(relativePath, handler)\n return group.returnObj()\n}\n\n// Static serves files from the given file system root.\n// Internally a http.FileServer is used, therefore http.NotFound is used instead\n// of the Router\'s NotFound handler.\n// To use the operating system\'s file system implementation,\n// use :\n//     router.Static("/static", "/var/www")\nfunc (group *RouterGroup) Static(relativePath, root string) IRoutes {\n return group.StaticFS(relativePath, Dir(root, false))\n}\n\n// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.\n// Gin by default user: gin.Dir()\nfunc (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes {\n if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") {\n  panic("URL parameters can not be used when serving a static folder")\n }\n handler := group.createStaticHandler(relativePath, fs)\n urlPattern := path.Join(relativePath, "/*filepath")\n\n // Register GET and HEAD handlers\n group.GET(urlPattern, handler)\n group.HEAD(urlPattern, handler)\n return group.returnObj()\n}\n\nfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc {\n absolutePath := group.calculateAbsolutePath(relativePath)\n fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))\n\n return func(c *Context) {\n  if _, noListing := fs.(*onlyFilesFS); noListing {\n   c.Writer.WriteHeader(http.StatusNotFound)\n  }\n\n  file := c.Param("filepath")\n  // Check if file exists and/or if we have permission to access it\n  f, err := fs.Open(file)\n  if err != nil {\n   c.Writer.WriteHeader(http.StatusNotFound)\n   c.handlers = group.engine.noRoute\n   // Reset index\n   c.index = -1\n   return\n  }\n  f.Close()\n\n  fileServer.ServeHTTP(c.Writer, c.Request)\n }\n}\n\nfunc (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {\n finalSize := len(group.Handlers) + len(handlers)\n if finalSize >= int(abortIndex) {\n  panic("too many handlers")\n }\n mergedHandlers := make(HandlersChain, finalSize)\n copy(mergedHandlers, group.Handlers)\n copy(mergedHandlers[len(group.Handlers):], handlers)\n return mergedHandlers\n}\n\nfunc (group *RouterGroup) calculateAbsolutePath(relativePath string) string {\n return joinPaths(group.basePath, relativePath)\n}\n\nfunc (group *RouterGroup) returnObj() IRoutes {\n if group.root {\n  return group.engine\n }\n return group\n}\n\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>u,x:()=>s});var r=t(96540);const a={},o=r.createContext(a);function u(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:u(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);