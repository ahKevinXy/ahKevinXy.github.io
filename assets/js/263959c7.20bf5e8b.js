"use strict";(self.webpackChunkah_kevin_xy=self.webpackChunkah_kevin_xy||[]).push([[2473],{3905:function(e,n,t){t.d(n,{Zo:function(){return h},kt:function(){return c}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):u(u({},n),e)),t},h=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),p=l(t),c=a,g=p["".concat(s,".").concat(c)]||p[c]||d[c]||o;return t?r.createElement(g,u(u({ref:n},h),{},{components:t})):r.createElement(g,u({ref:n},h))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,u=new Array(o);u[0]=p;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,u[1]=i;for(var l=2;l<o;l++)u[l]=t[l];return r.createElement.apply(null,u)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},32835:function(e,n,t){t.r(n),t.d(n,{assets:function(){return h},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return d}});var r=t(87462),a=t(63366),o=(t(67294),t(3905)),u=["components"],i={},s="router_group",l={unversionedId:"backend/go/gin/source/1.7.7/router_group",id:"backend/go/gin/source/1.7.7/router_group",title:"router_group",description:"",source:"@site/docs/backend/go/gin/source/1.7.7/router_group.md",sourceDirName:"backend/go/gin/source/1.7.7",slug:"/backend/go/gin/source/1.7.7/router_group",permalink:"/docs/backend/go/gin/source/1.7.7/router_group",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"response_write",permalink:"/docs/backend/go/gin/source/1.7.7/reponse_writer"},next:{title:"tree",permalink:"/docs/backend/go/gin/source/1.7.7/tree"}},h={},d=[],p={toc:d};function c(e){var n=e.components,t=(0,a.Z)(e,u);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"router_group"},"router_group"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// Copyright 2014 Manu Martinez-Almeida.  All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n "net/http"\n "path"\n "regexp"\n "strings"\n)\n\n// IRouter defines all router handle interface includes single and group router.\ntype IRouter interface {\n IRoutes\n Group(string, ...HandlerFunc) *RouterGroup\n}\n\n// IRoutes defines all router handle interface.\ntype IRoutes interface {\n Use(...HandlerFunc) IRoutes\n\n Handle(string, string, ...HandlerFunc) IRoutes\n Any(string, ...HandlerFunc) IRoutes\n GET(string, ...HandlerFunc) IRoutes\n POST(string, ...HandlerFunc) IRoutes\n DELETE(string, ...HandlerFunc) IRoutes\n PATCH(string, ...HandlerFunc) IRoutes\n PUT(string, ...HandlerFunc) IRoutes\n OPTIONS(string, ...HandlerFunc) IRoutes\n HEAD(string, ...HandlerFunc) IRoutes\n\n StaticFile(string, string) IRoutes\n Static(string, string) IRoutes\n StaticFS(string, http.FileSystem) IRoutes\n}\n\n// RouterGroup is used internally to configure router, a RouterGroup is associated with\n// a prefix and an array of handlers (middleware).\ntype RouterGroup struct {\n Handlers HandlersChain\n basePath string\n engine   *Engine\n root     bool\n}\n\nvar _ IRouter = &RouterGroup{}\n\n// Use adds middleware to the group, see example code in GitHub.\nfunc (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes {\n group.Handlers = append(group.Handlers, middleware...)\n return group.returnObj()\n}\n\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.\n// For example, all the routes that use a common middleware for authorization could be grouped.\nfunc (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup {\n return &RouterGroup{\n  Handlers: group.combineHandlers(handlers),\n  basePath: group.calculateAbsolutePath(relativePath),\n  engine:   group.engine,\n }\n}\n\n// BasePath returns the base path of router group.\n// For example, if v := router.Group("/rest/n/v1/api"), v.BasePath() is "/rest/n/v1/api".\nfunc (group *RouterGroup) BasePath() string {\n return group.basePath\n}\n\nfunc (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {\n absolutePath := group.calculateAbsolutePath(relativePath)\n handlers = group.combineHandlers(handlers)\n group.engine.addRoute(httpMethod, absolutePath, handlers)\n return group.returnObj()\n}\n\n// Handle registers a new request handle and middleware with the given path and method.\n// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.\n// See the example code in GitHub.\n//\n// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut\n// functions can be used.\n//\n// This function is intended for bulk loading and to allow the usage of less\n// frequently used, non-standardized or custom methods (e.g. for internal\n// communication with a proxy).\nfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {\n if matches, err := regexp.MatchString("^[A-Z]+$", httpMethod); !matches || err != nil {\n  panic("http method " + httpMethod + " is not valid")\n }\n return group.handle(httpMethod, relativePath, handlers)\n}\n\n// POST is a shortcut for router.Handle("POST", path, handle).\nfunc (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPost, relativePath, handlers)\n}\n\n// GET is a shortcut for router.Handle("GET", path, handle).\nfunc (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodGet, relativePath, handlers)\n}\n\n// DELETE is a shortcut for router.Handle("DELETE", path, handle).\nfunc (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodDelete, relativePath, handlers)\n}\n\n// PATCH is a shortcut for router.Handle("PATCH", path, handle).\nfunc (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPatch, relativePath, handlers)\n}\n\n// PUT is a shortcut for router.Handle("PUT", path, handle).\nfunc (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodPut, relativePath, handlers)\n}\n\n// OPTIONS is a shortcut for router.Handle("OPTIONS", path, handle).\nfunc (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodOptions, relativePath, handlers)\n}\n\n// HEAD is a shortcut for router.Handle("HEAD", path, handle).\nfunc (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes {\n return group.handle(http.MethodHead, relativePath, handlers)\n}\n\n// Any registers a route that matches all the HTTP methods.\n// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes {\n group.handle(http.MethodGet, relativePath, handlers)\n group.handle(http.MethodPost, relativePath, handlers)\n group.handle(http.MethodPut, relativePath, handlers)\n group.handle(http.MethodPatch, relativePath, handlers)\n group.handle(http.MethodHead, relativePath, handlers)\n group.handle(http.MethodOptions, relativePath, handlers)\n group.handle(http.MethodDelete, relativePath, handlers)\n group.handle(http.MethodConnect, relativePath, handlers)\n group.handle(http.MethodTrace, relativePath, handlers)\n return group.returnObj()\n}\n\n// StaticFile registers a single route in order to serve a single file of the local filesystem.\n// router.StaticFile("favicon.ico", "./resources/favicon.ico")\nfunc (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes {\n if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") {\n  panic("URL parameters can not be used when serving a static file")\n }\n handler := func(c *Context) {\n  c.File(filepath)\n }\n group.GET(relativePath, handler)\n group.HEAD(relativePath, handler)\n return group.returnObj()\n}\n\n// Static serves files from the given file system root.\n// Internally a http.FileServer is used, therefore http.NotFound is used instead\n// of the Router\'s NotFound handler.\n// To use the operating system\'s file system implementation,\n// use :\n//     router.Static("/static", "/var/www")\nfunc (group *RouterGroup) Static(relativePath, root string) IRoutes {\n return group.StaticFS(relativePath, Dir(root, false))\n}\n\n// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.\n// Gin by default user: gin.Dir()\nfunc (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes {\n if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") {\n  panic("URL parameters can not be used when serving a static folder")\n }\n handler := group.createStaticHandler(relativePath, fs)\n urlPattern := path.Join(relativePath, "/*filepath")\n\n // Register GET and HEAD handlers\n group.GET(urlPattern, handler)\n group.HEAD(urlPattern, handler)\n return group.returnObj()\n}\n\nfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc {\n absolutePath := group.calculateAbsolutePath(relativePath)\n fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))\n\n return func(c *Context) {\n  if _, noListing := fs.(*onlyFilesFS); noListing {\n   c.Writer.WriteHeader(http.StatusNotFound)\n  }\n\n  file := c.Param("filepath")\n  // Check if file exists and/or if we have permission to access it\n  f, err := fs.Open(file)\n  if err != nil {\n   c.Writer.WriteHeader(http.StatusNotFound)\n   c.handlers = group.engine.noRoute\n   // Reset index\n   c.index = -1\n   return\n  }\n  f.Close()\n\n  fileServer.ServeHTTP(c.Writer, c.Request)\n }\n}\n\nfunc (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {\n finalSize := len(group.Handlers) + len(handlers)\n if finalSize >= int(abortIndex) {\n  panic("too many handlers")\n }\n mergedHandlers := make(HandlersChain, finalSize)\n copy(mergedHandlers, group.Handlers)\n copy(mergedHandlers[len(group.Handlers):], handlers)\n return mergedHandlers\n}\n\nfunc (group *RouterGroup) calculateAbsolutePath(relativePath string) string {\n return joinPaths(group.basePath, relativePath)\n}\n\nfunc (group *RouterGroup) returnObj() IRoutes {\n if group.root {\n  return group.engine\n }\n return group\n}\n\n')))}c.isMDXComponent=!0}}]);