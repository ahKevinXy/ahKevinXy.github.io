"use strict";(self.webpackChunkah_kevin_xy=self.webpackChunkah_kevin_xy||[]).push([[4631],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),u=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=u(e.components);return r.createElement(c.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),f=u(t),h=i,p=f["".concat(c,".").concat(h)]||f[h]||l[h]||o;return t?r.createElement(p,a(a({ref:n},d),{},{components:t})):r.createElement(p,a({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=f;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var u=2;u<o;u++)a[u]=t[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},12673:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return l}});var r=t(87462),i=t(63366),o=(t(67294),t(3905)),a=["components"],s={},c="gin context",u={unversionedId:"backend/go/gin/source/1.7.7/context",id:"backend/go/gin/source/1.7.7/context",title:"gin context",description:"",source:"@site/docs/backend/go/gin/source/1.7.7/context.md",sourceDirName:"backend/go/gin/source/1.7.7",slug:"/backend/go/gin/source/1.7.7/context",permalink:"/docs/backend/go/gin/source/1.7.7/context",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u6e90\u7801\u89e3\u6790",permalink:"/docs/backend/go/gin/source/"},next:{title:"error",permalink:"/docs/backend/go/gin/source/1.7.7/error"}},d={},l=[],f={toc:l};function h(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"gin-context"},"gin context"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'\npackage gin\n\nimport (\n "errors"\n "fmt"\n "io"\n "io/ioutil"\n "log"\n "math"\n "mime/multipart"\n "net"\n "net/http"\n "net/url"\n "os"\n "strings"\n "sync"\n "time"\n\n "github.com/gin-contrib/sse"\n "github.com/gin-gonic/gin/binding"\n "github.com/gin-gonic/gin/render"\n)\n\n// Content-Type MIME of the most common data formats.\nconst (\n MIMEJSON              = binding.MIMEJSON\n MIMEHTML              = binding.MIMEHTML\n MIMEXML               = binding.MIMEXML\n MIMEXML2              = binding.MIMEXML2\n MIMEPlain             = binding.MIMEPlain\n MIMEPOSTForm          = binding.MIMEPOSTForm\n MIMEMultipartPOSTForm = binding.MIMEMultipartPOSTForm\n MIMEYAML              = binding.MIMEYAML\n)\n\n// BodyBytesKey indicates a default body bytes key.\nconst BodyBytesKey = "_gin-gonic/gin/bodybyteskey"\n\nconst abortIndex int8 = math.MaxInt8 / 2\n\n// Context is the most important part of gin. It allows us to pass variables between middleware,\n// manage the flow, validate the JSON of a request and render a JSON response for example.\ntype Context struct {\n writermem responseWriter\n Request   *http.Request\n Writer    ResponseWriter\n\n Params   Params\n handlers HandlersChain\n index    int8\n fullPath string\n\n engine       *Engine\n params       *Params\n skippedNodes *[]skippedNode\n\n // This mutex protect Keys map\n mu sync.RWMutex\n\n // Keys is a key/value pair exclusively for the context of each request.\n Keys map[string]interface{}\n\n // Errors is a list of errors attached to all the handlers/middlewares who used this context.\n Errors errorMsgs\n\n // Accepted defines a list of manually accepted formats for content negotiation.\n Accepted []string\n\n // queryCache use url.ParseQuery cached the param query result from c.Request.URL.Query()\n queryCache url.Values\n\n // formCache use url.ParseQuery cached PostForm contains the parsed form data from POST, PATCH,\n // or PUT body parameters.\n formCache url.Values\n\n // SameSite allows a server to define a cookie attribute making it impossible for\n // the browser to send this cookie along with cross-site requests.\n sameSite http.SameSite\n}\n\n/************************************/\n/********** CONTEXT CREATION ********/\n/************************************/\n\nfunc (c *Context) reset() {\n c.Writer = &c.writermem\n c.Params = c.Params[0:0]\n c.handlers = nil\n c.index = -1\n\n c.fullPath = ""\n c.Keys = nil\n c.Errors = c.Errors[0:0]\n c.Accepted = nil\n c.queryCache = nil\n c.formCache = nil\n *c.params = (*c.params)[:0]\n *c.skippedNodes = (*c.skippedNodes)[:0]\n}\n\n// Copy returns a copy of the current context that can be safely used outside the request\'s scope.\n// This has to be used when the context has to be passed to a goroutine.\nfunc (c *Context) Copy() *Context {\n cp := Context{\n  writermem: c.writermem,\n  Request:   c.Request,\n  Params:    c.Params,\n  engine:    c.engine,\n }\n cp.writermem.ResponseWriter = nil\n cp.Writer = &cp.writermem\n cp.index = abortIndex\n cp.handlers = nil\n cp.Keys = map[string]interface{}{}\n for k, v := range c.Keys {\n  cp.Keys[k] = v\n }\n paramCopy := make([]Param, len(cp.Params))\n copy(paramCopy, cp.Params)\n cp.Params = paramCopy\n return &cp\n}\n\n// HandlerName returns the main handler\'s name. For example if the handler is "handleGetUsers()",\n// this function will return "main.handleGetUsers".\nfunc (c *Context) HandlerName() string {\n return nameOfFunction(c.handlers.Last())\n}\n\n// HandlerNames returns a list of all registered handlers for this context in descending order,\n// following the semantics of HandlerName()\nfunc (c *Context) HandlerNames() []string {\n hn := make([]string, 0, len(c.handlers))\n for _, val := range c.handlers {\n  hn = append(hn, nameOfFunction(val))\n }\n return hn\n}\n\n// Handler returns the main handler.\nfunc (c *Context) Handler() HandlerFunc {\n return c.handlers.Last()\n}\n\n// FullPath returns a matched route full path. For not found routes\n// returns an empty string.\n//     router.GET("/user/:id", func(c *gin.Context) {\n//         c.FullPath() == "/user/:id" // true\n//     })\nfunc (c *Context) FullPath() string {\n return c.fullPath\n}\n\n/************************************/\n/*********** FLOW CONTROL ***********/\n/************************************/\n\n// Next should be used only inside middleware.\n// It executes the pending handlers in the chain inside the calling handler.\n// See example in GitHub.\nfunc (c *Context) Next() {\n c.index++\n for c.index < int8(len(c.handlers)) {\n  c.handlers[c.index](c)\n  c.index++\n }\n}\n\n// IsAborted returns true if the current context was aborted.\nfunc (c *Context) IsAborted() bool {\n return c.index >= abortIndex\n}\n\n// Abort prevents pending handlers from being called. Note that this will not stop the current handler.\n// Let\'s say you have an authorization middleware that validates that the current request is authorized.\n// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers\n// for this request are not called.\nfunc (c *Context) Abort() {\n c.index = abortIndex\n}\n\n// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.\n// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).\nfunc (c *Context) AbortWithStatus(code int) {\n c.Status(code)\n c.Writer.WriteHeaderNow()\n c.Abort()\n}\n\n// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.\n// This method stops the chain, writes the status code and return a JSON body.\n// It also sets the Content-Type as "application/json".\nfunc (c *Context) AbortWithStatusJSON(code int, jsonObj interface{}) {\n c.Abort()\n c.JSON(code, jsonObj)\n}\n\n// AbortWithError calls `AbortWithStatus()` and `Error()` internally.\n// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.\n// See Context.Error() for more details.\nfunc (c *Context) AbortWithError(code int, err error) *Error {\n c.AbortWithStatus(code)\n return c.Error(err)\n}\n\n/************************************/\n/********* ERROR MANAGEMENT *********/\n/************************************/\n\n// Error attaches an error to the current context. The error is pushed to a list of errors.\n// It\'s a good idea to call Error for each error that occurred during the resolution of a request.\n// A middleware can be used to collect all the errors and push them to a database together,\n// print a log, or append it in the HTTP response.\n// Error will panic if err is nil.\nfunc (c *Context) Error(err error) *Error {\n if err == nil {\n  panic("err is nil")\n }\n\n parsedError, ok := err.(*Error)\n if !ok {\n  parsedError = &Error{\n   Err:  err,\n   Type: ErrorTypePrivate,\n  }\n }\n\n c.Errors = append(c.Errors, parsedError)\n return parsedError\n}\n\n/************************************/\n/******** METADATA MANAGEMENT********/\n/************************************/\n\n// Set is used to store a new key/value pair exclusively for this context.\n// It also lazy initializes  c.Keys if it was not used previously.\nfunc (c *Context) Set(key string, value interface{}) {\n c.mu.Lock()\n if c.Keys == nil {\n  c.Keys = make(map[string]interface{})\n }\n\n c.Keys[key] = value\n c.mu.Unlock()\n}\n\n// Get returns the value for the given key, ie: (value, true).\n// If the value does not exists it returns (nil, false)\nfunc (c *Context) Get(key string) (value interface{}, exists bool) {\n c.mu.RLock()\n value, exists = c.Keys[key]\n c.mu.RUnlock()\n return\n}\n\n// MustGet returns the value for the given key if it exists, otherwise it panics.\nfunc (c *Context) MustGet(key string) interface{} {\n if value, exists := c.Get(key); exists {\n  return value\n }\n panic("Key \\"" + key + "\\" does not exist")\n}\n\n// GetString returns the value associated with the key as a string.\nfunc (c *Context) GetString(key string) (s string) {\n if val, ok := c.Get(key); ok && val != nil {\n  s, _ = val.(string)\n }\n return\n}\n\n// GetBool returns the value associated with the key as a boolean.\nfunc (c *Context) GetBool(key string) (b bool) {\n if val, ok := c.Get(key); ok && val != nil {\n  b, _ = val.(bool)\n }\n return\n}\n\n// GetInt returns the value associated with the key as an integer.\nfunc (c *Context) GetInt(key string) (i int) {\n if val, ok := c.Get(key); ok && val != nil {\n  i, _ = val.(int)\n }\n return\n}\n\n// GetInt64 returns the value associated with the key as an integer.\nfunc (c *Context) GetInt64(key string) (i64 int64) {\n if val, ok := c.Get(key); ok && val != nil {\n  i64, _ = val.(int64)\n }\n return\n}\n\n// GetUint returns the value associated with the key as an unsigned integer.\nfunc (c *Context) GetUint(key string) (ui uint) {\n if val, ok := c.Get(key); ok && val != nil {\n  ui, _ = val.(uint)\n }\n return\n}\n\n// GetUint64 returns the value associated with the key as an unsigned integer.\nfunc (c *Context) GetUint64(key string) (ui64 uint64) {\n if val, ok := c.Get(key); ok && val != nil {\n  ui64, _ = val.(uint64)\n }\n return\n}\n\n// GetFloat64 returns the value associated with the key as a float64.\nfunc (c *Context) GetFloat64(key string) (f64 float64) {\n if val, ok := c.Get(key); ok && val != nil {\n  f64, _ = val.(float64)\n }\n return\n}\n\n// GetTime returns the value associated with the key as time.\nfunc (c *Context) GetTime(key string) (t time.Time) {\n if val, ok := c.Get(key); ok && val != nil {\n  t, _ = val.(time.Time)\n }\n return\n}\n\n// GetDuration returns the value associated with the key as a duration.\nfunc (c *Context) GetDuration(key string) (d time.Duration) {\n if val, ok := c.Get(key); ok && val != nil {\n  d, _ = val.(time.Duration)\n }\n return\n}\n\n// GetStringSlice returns the value associated with the key as a slice of strings.\nfunc (c *Context) GetStringSlice(key string) (ss []string) {\n if val, ok := c.Get(key); ok && val != nil {\n  ss, _ = val.([]string)\n }\n return\n}\n\n// GetStringMap returns the value associated with the key as a map of interfaces.\nfunc (c *Context) GetStringMap(key string) (sm map[string]interface{}) {\n if val, ok := c.Get(key); ok && val != nil {\n  sm, _ = val.(map[string]interface{})\n }\n return\n}\n\n// GetStringMapString returns the value associated with the key as a map of strings.\nfunc (c *Context) GetStringMapString(key string) (sms map[string]string) {\n if val, ok := c.Get(key); ok && val != nil {\n  sms, _ = val.(map[string]string)\n }\n return\n}\n\n// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.\nfunc (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string) {\n if val, ok := c.Get(key); ok && val != nil {\n  smss, _ = val.(map[string][]string)\n }\n return\n}\n\n/************************************/\n/************ INPUT DATA ************/\n/************************************/\n\n// Param returns the value of the URL param.\n// It is a shortcut for c.Params.ByName(key)\n//     router.GET("/user/:id", func(c *gin.Context) {\n//         // a GET request to /user/john\n//         id := c.Param("id") // id == "john"\n//     })\nfunc (c *Context) Param(key string) string {\n return c.Params.ByName(key)\n}\n\n// Query returns the keyed url query value if it exists,\n// otherwise it returns an empty string `("")`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//     GET /path?id=1234&name=Manu&value=\n//     c.Query("id") == "1234"\n//     c.Query("name") == "Manu"\n//     c.Query("value") == ""\n//     c.Query("wtf") == ""\nfunc (c *Context) Query(key string) string {\n value, _ := c.GetQuery(key)\n return value\n}\n\n// DefaultQuery returns the keyed url query value if it exists,\n// otherwise it returns the specified defaultValue string.\n// See: Query() and GetQuery() for further information.\n//     GET /?name=Manu&lastname=\n//     c.DefaultQuery("name", "unknown") == "Manu"\n//     c.DefaultQuery("id", "none") == "none"\n//     c.DefaultQuery("lastname", "none") == ""\nfunc (c *Context) DefaultQuery(key, defaultValue string) string {\n if value, ok := c.GetQuery(key); ok {\n  return value\n }\n return defaultValue\n}\n\n// GetQuery is like Query(), it returns the keyed url query value\n// if it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns `("", false)`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//     GET /?name=Manu&lastname=\n//     ("Manu", true) == c.GetQuery("name")\n//     ("", false) == c.GetQuery("id")\n//     ("", true) == c.GetQuery("lastname")\nfunc (c *Context) GetQuery(key string) (string, bool) {\n if values, ok := c.GetQueryArray(key); ok {\n  return values[0], ok\n }\n return "", false\n}\n\n// QueryArray returns a slice of strings for a given query key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) QueryArray(key string) []string {\n values, _ := c.GetQueryArray(key)\n return values\n}\n\nfunc (c *Context) initQueryCache() {\n if c.queryCache == nil {\n  if c.Request != nil {\n   c.queryCache = c.Request.URL.Query()\n  } else {\n   c.queryCache = url.Values{}\n  }\n }\n}\n\n// GetQueryArray returns a slice of strings for a given query key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetQueryArray(key string) ([]string, bool) {\n c.initQueryCache()\n if values, ok := c.queryCache[key]; ok && len(values) > 0 {\n  return values, true\n }\n return []string{}, false\n}\n\n// QueryMap returns a map for a given query key.\nfunc (c *Context) QueryMap(key string) map[string]string {\n dicts, _ := c.GetQueryMap(key)\n return dicts\n}\n\n// GetQueryMap returns a map for a given query key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetQueryMap(key string) (map[string]string, bool) {\n c.initQueryCache()\n return c.get(c.queryCache, key)\n}\n\n// PostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns an empty string `("")`.\nfunc (c *Context) PostForm(key string) string {\n value, _ := c.GetPostForm(key)\n return value\n}\n\n// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns the specified defaultValue string.\n// See: PostForm() and GetPostForm() for further information.\nfunc (c *Context) DefaultPostForm(key, defaultValue string) string {\n if value, ok := c.GetPostForm(key); ok {\n  return value\n }\n return defaultValue\n}\n\n// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded\n// form or multipart form when it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns ("", false).\n// For example, during a PATCH request to update the user\'s email:\n//     email=mail@example.com  --\x3e  ("mail@example.com", true) := GetPostForm("email") // set email to "mail@example.com"\n//     email=                  --\x3e  ("", true) := GetPostForm("email") // set email to ""\n//                             --\x3e  ("", false) := GetPostForm("email") // do nothing with email\nfunc (c *Context) GetPostForm(key string) (string, bool) {\n if values, ok := c.GetPostFormArray(key); ok {\n  return values[0], ok\n }\n return "", false\n}\n\n// PostFormArray returns a slice of strings for a given form key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) PostFormArray(key string) []string {\n values, _ := c.GetPostFormArray(key)\n return values\n}\n\nfunc (c *Context) initFormCache() {\n if c.formCache == nil {\n  c.formCache = make(url.Values)\n  req := c.Request\n  if err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n   if err != http.ErrNotMultipart {\n    debugPrint("error on parse multipart form array: %v", err)\n   }\n  }\n  c.formCache = req.PostForm\n }\n}\n\n// GetPostFormArray returns a slice of strings for a given form key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormArray(key string) ([]string, bool) {\n c.initFormCache()\n if values := c.formCache[key]; len(values) > 0 {\n  return values, true\n }\n return []string{}, false\n}\n\n// PostFormMap returns a map for a given form key.\nfunc (c *Context) PostFormMap(key string) map[string]string {\n dicts, _ := c.GetPostFormMap(key)\n return dicts\n}\n\n// GetPostFormMap returns a map for a given form key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormMap(key string) (map[string]string, bool) {\n c.initFormCache()\n return c.get(c.formCache, key)\n}\n\n// get is an internal method and returns a map which satisfy conditions.\nfunc (c *Context) get(m map[string][]string, key string) (map[string]string, bool) {\n dicts := make(map[string]string)\n exist := false\n for k, v := range m {\n  if i := strings.IndexByte(k, \'[\'); i >= 1 && k[0:i] == key {\n   if j := strings.IndexByte(k[i+1:], \']\'); j >= 1 {\n    exist = true\n    dicts[k[i+1:][:j]] = v[0]\n   }\n  }\n }\n return dicts, exist\n}\n\n// FormFile returns the first file for the provided form key.\nfunc (c *Context) FormFile(name string) (*multipart.FileHeader, error) {\n if c.Request.MultipartForm == nil {\n  if err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n   return nil, err\n  }\n }\n f, fh, err := c.Request.FormFile(name)\n if err != nil {\n  return nil, err\n }\n f.Close()\n return fh, err\n}\n\n// MultipartForm is the parsed multipart form, including file uploads.\nfunc (c *Context) MultipartForm() (*multipart.Form, error) {\n err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory)\n return c.Request.MultipartForm, err\n}\n\n// SaveUploadedFile uploads the form file to specific dst.\nfunc (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error {\n src, err := file.Open()\n if err != nil {\n  return err\n }\n defer src.Close()\n\n out, err := os.Create(dst)\n if err != nil {\n  return err\n }\n defer out.Close()\n\n _, err = io.Copy(out, src)\n return err\n}\n\n// Bind checks the Content-Type to select a binding engine automatically,\n// Depending the "Content-Type" header different bindings are used:\n//     "application/json" --\x3e JSON binding\n//     "application/xml"  --\x3e XML binding\n// otherwise --\x3e returns an error.\n// It parses the request\'s body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// It writes a 400 error and sets Content-Type header "text/plain" in the response if input is not valid.\nfunc (c *Context) Bind(obj interface{}) error {\n b := binding.Default(c.Request.Method, c.ContentType())\n return c.MustBindWith(obj, b)\n}\n\n// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).\nfunc (c *Context) BindJSON(obj interface{}) error {\n return c.MustBindWith(obj, binding.JSON)\n}\n\n// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).\nfunc (c *Context) BindXML(obj interface{}) error {\n return c.MustBindWith(obj, binding.XML)\n}\n\n// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).\nfunc (c *Context) BindQuery(obj interface{}) error {\n return c.MustBindWith(obj, binding.Query)\n}\n\n// BindYAML is a shortcut for c.MustBindWith(obj, binding.YAML).\nfunc (c *Context) BindYAML(obj interface{}) error {\n return c.MustBindWith(obj, binding.YAML)\n}\n\n// BindHeader is a shortcut for c.MustBindWith(obj, binding.Header).\nfunc (c *Context) BindHeader(obj interface{}) error {\n return c.MustBindWith(obj, binding.Header)\n}\n\n// BindUri binds the passed struct pointer using binding.Uri.\n// It will abort the request with HTTP 400 if any error occurs.\nfunc (c *Context) BindUri(obj interface{}) error {\n if err := c.ShouldBindUri(obj); err != nil {\n  c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck\n  return err\n }\n return nil\n}\n\n// MustBindWith binds the passed struct pointer using the specified binding engine.\n// It will abort the request with HTTP 400 if any error occurs.\n// See the binding package.\nfunc (c *Context) MustBindWith(obj interface{}, b binding.Binding) error {\n if err := c.ShouldBindWith(obj, b); err != nil {\n  c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck\n  return err\n }\n return nil\n}\n\n// ShouldBind checks the Content-Type to select a binding engine automatically,\n// Depending the "Content-Type" header different bindings are used:\n//     "application/json" --\x3e JSON binding\n//     "application/xml"  --\x3e XML binding\n// otherwise --\x3e returns an error\n// It parses the request\'s body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid.\nfunc (c *Context) ShouldBind(obj interface{}) error {\n b := binding.Default(c.Request.Method, c.ContentType())\n return c.ShouldBindWith(obj, b)\n}\n\n// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).\nfunc (c *Context) ShouldBindJSON(obj interface{}) error {\n return c.ShouldBindWith(obj, binding.JSON)\n}\n\n// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).\nfunc (c *Context) ShouldBindXML(obj interface{}) error {\n return c.ShouldBindWith(obj, binding.XML)\n}\n\n// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).\nfunc (c *Context) ShouldBindQuery(obj interface{}) error {\n return c.ShouldBindWith(obj, binding.Query)\n}\n\n// ShouldBindYAML is a shortcut for c.ShouldBindWith(obj, binding.YAML).\nfunc (c *Context) ShouldBindYAML(obj interface{}) error {\n return c.ShouldBindWith(obj, binding.YAML)\n}\n\n// ShouldBindHeader is a shortcut for c.ShouldBindWith(obj, binding.Header).\nfunc (c *Context) ShouldBindHeader(obj interface{}) error {\n return c.ShouldBindWith(obj, binding.Header)\n}\n\n// ShouldBindUri binds the passed struct pointer using the specified binding engine.\nfunc (c *Context) ShouldBindUri(obj interface{}) error {\n m := make(map[string][]string)\n for _, v := range c.Params {\n  m[v.Key] = []string{v.Value}\n }\n return binding.Uri.BindUri(m, obj)\n}\n\n// ShouldBindWith binds the passed struct pointer using the specified binding engine.\n// See the binding package.\nfunc (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error {\n return b.Bind(c.Request, obj)\n}\n\n// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request\n// body into the context, and reuse when it is called again.\n//\n// NOTE: This method reads the body before binding. So you should use\n// ShouldBindWith for better performance if you need to call only once.\nfunc (c *Context) ShouldBindBodyWith(obj interface{}, bb binding.BindingBody) (err error) {\n var body []byte\n if cb, ok := c.Get(BodyBytesKey); ok {\n  if cbb, ok := cb.([]byte); ok {\n   body = cbb\n  }\n }\n if body == nil {\n  body, err = ioutil.ReadAll(c.Request.Body)\n  if err != nil {\n   return err\n  }\n  c.Set(BodyBytesKey, body)\n }\n return bb.BindBody(body, obj)\n}\n\n// ClientIP implements one best effort algorithm to return the real client IP.\n// It called c.RemoteIP() under the hood, to check if the remote IP is a trusted proxy or not.\n// If it is it will then try to parse the headers defined in Engine.RemoteIPHeaders (defaulting to [X-Forwarded-For, X-Real-Ip]).\n// If the headers are not syntactically valid OR the remote IP does not correspond to a trusted proxy,\n// the remote IP (coming form Request.RemoteAddr) is returned.\nfunc (c *Context) ClientIP() string {\n // Check if we\'re running on a trusted platform, continue running backwards if error\n if c.engine.TrustedPlatform != "" {\n  // Developers can define their own header of Trusted Platform or use predefined constants\n  if addr := c.requestHeader(c.engine.TrustedPlatform); addr != "" {\n   return addr\n  }\n }\n\n // Legacy "AppEngine" flag\n if c.engine.AppEngine {\n  log.Println(`The AppEngine flag is going to be deprecated. Please check issues #2723 and #2739 and use \'TrustedPlatform: gin.PlatformGoogleAppEngine\' instead.`)\n  if addr := c.requestHeader("X-Appengine-Remote-Addr"); addr != "" {\n   return addr\n  }\n }\n\n remoteIP, trusted := c.RemoteIP()\n if remoteIP == nil {\n  return ""\n }\n\n if trusted && c.engine.ForwardedByClientIP && c.engine.RemoteIPHeaders != nil {\n  for _, headerName := range c.engine.RemoteIPHeaders {\n   ip, valid := c.engine.validateHeader(c.requestHeader(headerName))\n   if valid {\n    return ip\n   }\n  }\n }\n return remoteIP.String()\n}\n\nfunc (e *Engine) isTrustedProxy(ip net.IP) bool {\n if e.trustedCIDRs != nil {\n  for _, cidr := range e.trustedCIDRs {\n   if cidr.Contains(ip) {\n    return true\n   }\n  }\n }\n return false\n}\n\n// RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port).\n// It also checks if the remoteIP is a trusted proxy or not.\n// In order to perform this validation, it will see if the IP is contained within at least one of the CIDR blocks\n// defined by Engine.SetTrustedProxies()\nfunc (c *Context) RemoteIP() (net.IP, bool) {\n ip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr))\n if err != nil {\n  return nil, false\n }\n remoteIP := net.ParseIP(ip)\n if remoteIP == nil {\n  return nil, false\n }\n\n return remoteIP, c.engine.isTrustedProxy(remoteIP)\n}\n\nfunc (e *Engine) validateHeader(header string) (clientIP string, valid bool) {\n if header == "" {\n  return "", false\n }\n items := strings.Split(header, ",")\n for i := len(items) - 1; i >= 0; i-- {\n  ipStr := strings.TrimSpace(items[i])\n  ip := net.ParseIP(ipStr)\n  if ip == nil {\n   return "", false\n  }\n\n  // X-Forwarded-For is appended by proxy\n  // Check IPs in reverse order and stop when find untrusted proxy\n  if (i == 0) || (!e.isTrustedProxy(ip)) {\n   return ipStr, true\n  }\n }\n return\n}\n\n// ContentType returns the Content-Type header of the request.\nfunc (c *Context) ContentType() string {\n return filterFlags(c.requestHeader("Content-Type"))\n}\n\n// IsWebsocket returns true if the request headers indicate that a websocket\n// handshake is being initiated by the client.\nfunc (c *Context) IsWebsocket() bool {\n if strings.Contains(strings.ToLower(c.requestHeader("Connection")), "upgrade") &&\n  strings.EqualFold(c.requestHeader("Upgrade"), "websocket") {\n  return true\n }\n return false\n}\n\nfunc (c *Context) requestHeader(key string) string {\n return c.Request.Header.Get(key)\n}\n\n/************************************/\n/******** RESPONSE RENDERING ********/\n/************************************/\n\n// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.\nfunc bodyAllowedForStatus(status int) bool {\n switch {\n case status >= 100 && status <= 199:\n  return false\n case status == http.StatusNoContent:\n  return false\n case status == http.StatusNotModified:\n  return false\n }\n return true\n}\n\n// Status sets the HTTP response code.\nfunc (c *Context) Status(code int) {\n c.Writer.WriteHeader(code)\n}\n\n// Header is a intelligent shortcut for c.Writer.Header().Set(key, value).\n// It writes a header in the response.\n// If value == "", this method removes the header `c.Writer.Header().Del(key)`\nfunc (c *Context) Header(key, value string) {\n if value == "" {\n  c.Writer.Header().Del(key)\n  return\n }\n c.Writer.Header().Set(key, value)\n}\n\n// GetHeader returns value from request headers.\nfunc (c *Context) GetHeader(key string) string {\n return c.requestHeader(key)\n}\n\n// GetRawData return stream data.\nfunc (c *Context) GetRawData() ([]byte, error) {\n return ioutil.ReadAll(c.Request.Body)\n}\n\n// SetSameSite with cookie\nfunc (c *Context) SetSameSite(samesite http.SameSite) {\n c.sameSite = samesite\n}\n\n// SetCookie adds a Set-Cookie header to the ResponseWriter\'s headers.\n// The provided cookie must have a valid Name. Invalid cookies may be\n// silently dropped.\nfunc (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) {\n if path == "" {\n  path = "/"\n }\n http.SetCookie(c.Writer, &http.Cookie{\n  Name:     name,\n  Value:    url.QueryEscape(value),\n  MaxAge:   maxAge,\n  Path:     path,\n  Domain:   domain,\n  SameSite: c.sameSite,\n  Secure:   secure,\n  HttpOnly: httpOnly,\n })\n}\n\n// Cookie returns the named cookie provided in the request or\n// ErrNoCookie if not found. And return the named cookie is unescaped.\n// If multiple cookies match the given name, only one cookie will\n// be returned.\nfunc (c *Context) Cookie(name string) (string, error) {\n cookie, err := c.Request.Cookie(name)\n if err != nil {\n  return "", err\n }\n val, _ := url.QueryUnescape(cookie.Value)\n return val, nil\n}\n\n// Render writes the response headers and calls render.Render to render data.\nfunc (c *Context) Render(code int, r render.Render) {\n c.Status(code)\n\n if !bodyAllowedForStatus(code) {\n  r.WriteContentType(c.Writer)\n  c.Writer.WriteHeaderNow()\n  return\n }\n\n if err := r.Render(c.Writer); err != nil {\n  panic(err)\n }\n}\n\n// HTML renders the HTTP template specified by its file name.\n// It also updates the HTTP code and sets the Content-Type as "text/html".\n// See http://golang.org/doc/articles/wiki/\nfunc (c *Context) HTML(code int, name string, obj interface{}) {\n instance := c.engine.HTMLRender.Instance(name, obj)\n c.Render(code, instance)\n}\n\n// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.\n// It also sets the Content-Type as "application/json".\n// WARNING: we recommend to use this only for development purposes since printing pretty JSON is\n// more CPU and bandwidth consuming. Use Context.JSON() instead.\nfunc (c *Context) IndentedJSON(code int, obj interface{}) {\n c.Render(code, render.IndentedJSON{Data: obj})\n}\n\n// SecureJSON serializes the given struct as Secure JSON into the response body.\n// Default prepends "while(1)," to response body if the given struct is array values.\n// It also sets the Content-Type as "application/json".\nfunc (c *Context) SecureJSON(code int, obj interface{}) {\n c.Render(code, render.SecureJSON{Prefix: c.engine.secureJSONPrefix, Data: obj})\n}\n\n// JSONP serializes the given struct as JSON into the response body.\n// It adds padding to response body to request data from a server residing in a different domain than the client.\n// It also sets the Content-Type as "application/javascript".\nfunc (c *Context) JSONP(code int, obj interface{}) {\n callback := c.DefaultQuery("callback", "")\n if callback == "" {\n  c.Render(code, render.JSON{Data: obj})\n  return\n }\n c.Render(code, render.JsonpJSON{Callback: callback, Data: obj})\n}\n\n// JSON serializes the given struct as JSON into the response body.\n// It also sets the Content-Type as "application/json".\nfunc (c *Context) JSON(code int, obj interface{}) {\n c.Render(code, render.JSON{Data: obj})\n}\n\n// AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string.\n// It also sets the Content-Type as "application/json".\nfunc (c *Context) AsciiJSON(code int, obj interface{}) {\n c.Render(code, render.AsciiJSON{Data: obj})\n}\n\n// PureJSON serializes the given struct as JSON into the response body.\n// PureJSON, unlike JSON, does not replace special html characters with their unicode entities.\nfunc (c *Context) PureJSON(code int, obj interface{}) {\n c.Render(code, render.PureJSON{Data: obj})\n}\n\n// XML serializes the given struct as XML into the response body.\n// It also sets the Content-Type as "application/xml".\nfunc (c *Context) XML(code int, obj interface{}) {\n c.Render(code, render.XML{Data: obj})\n}\n\n// YAML serializes the given struct as YAML into the response body.\nfunc (c *Context) YAML(code int, obj interface{}) {\n c.Render(code, render.YAML{Data: obj})\n}\n\n// ProtoBuf serializes the given struct as ProtoBuf into the response body.\nfunc (c *Context) ProtoBuf(code int, obj interface{}) {\n c.Render(code, render.ProtoBuf{Data: obj})\n}\n\n// String writes the given string into the response body.\nfunc (c *Context) String(code int, format string, values ...interface{}) {\n c.Render(code, render.String{Format: format, Data: values})\n}\n\n// Redirect returns a HTTP redirect to the specific location.\nfunc (c *Context) Redirect(code int, location string) {\n c.Render(-1, render.Redirect{\n  Code:     code,\n  Location: location,\n  Request:  c.Request,\n })\n}\n\n// Data writes some data into the body stream and updates the HTTP code.\nfunc (c *Context) Data(code int, contentType string, data []byte) {\n c.Render(code, render.Data{\n  ContentType: contentType,\n  Data:        data,\n })\n}\n\n// DataFromReader writes the specified reader into the body stream and updates the HTTP code.\nfunc (c *Context) DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string) {\n c.Render(code, render.Reader{\n  Headers:       extraHeaders,\n  ContentType:   contentType,\n  ContentLength: contentLength,\n  Reader:        reader,\n })\n}\n\n// File writes the specified file into the body stream in an efficient way.\nfunc (c *Context) File(filepath string) {\n http.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// FileFromFS writes the specified file from http.FileSystem into the body stream in an efficient way.\nfunc (c *Context) FileFromFS(filepath string, fs http.FileSystem) {\n defer func(old string) {\n  c.Request.URL.Path = old\n }(c.Request.URL.Path)\n\n c.Request.URL.Path = filepath\n\n http.FileServer(fs).ServeHTTP(c.Writer, c.Request)\n}\n\n// FileAttachment writes the specified file into the body stream in an efficient way\n// On the client side, the file will typically be downloaded with the given filename\nfunc (c *Context) FileAttachment(filepath, filename string) {\n c.Writer.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\\"%s\\"", filename))\n http.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// SSEvent writes a Server-Sent Event into the body stream.\nfunc (c *Context) SSEvent(name string, message interface{}) {\n c.Render(-1, sse.Event{\n  Event: name,\n  Data:  message,\n })\n}\n\n// Stream sends a streaming response and returns a boolean\n// indicates "Is client disconnected in middle of stream"\nfunc (c *Context) Stream(step func(w io.Writer) bool) bool {\n w := c.Writer\n clientGone := w.CloseNotify()\n for {\n  select {\n  case <-clientGone:\n   return true\n  default:\n   keepOpen := step(w)\n   w.Flush()\n   if !keepOpen {\n    return false\n   }\n  }\n }\n}\n\n/************************************/\n/******** CONTENT NEGOTIATION *******/\n/************************************/\n\n// Negotiate contains all negotiations data.\ntype Negotiate struct {\n Offered  []string\n HTMLName string\n HTMLData interface{}\n JSONData interface{}\n XMLData  interface{}\n YAMLData interface{}\n Data     interface{}\n}\n\n// Negotiate calls different Render according acceptable Accept format.\nfunc (c *Context) Negotiate(code int, config Negotiate) {\n switch c.NegotiateFormat(config.Offered...) {\n case binding.MIMEJSON:\n  data := chooseData(config.JSONData, config.Data)\n  c.JSON(code, data)\n\n case binding.MIMEHTML:\n  data := chooseData(config.HTMLData, config.Data)\n  c.HTML(code, config.HTMLName, data)\n\n case binding.MIMEXML:\n  data := chooseData(config.XMLData, config.Data)\n  c.XML(code, data)\n\n case binding.MIMEYAML:\n  data := chooseData(config.YAMLData, config.Data)\n  c.YAML(code, data)\n\n default:\n  c.AbortWithError(http.StatusNotAcceptable, errors.New("the accepted formats are not offered by the server")) // nolint: errcheck\n }\n}\n\n// NegotiateFormat returns an acceptable Accept format.\nfunc (c *Context) NegotiateFormat(offered ...string) string {\n assert1(len(offered) > 0, "you must provide at least one offer")\n\n if c.Accepted == nil {\n  c.Accepted = parseAccept(c.requestHeader("Accept"))\n }\n if len(c.Accepted) == 0 {\n  return offered[0]\n }\n for _, accepted := range c.Accepted {\n  for _, offer := range offered {\n   // According to RFC 2616 and RFC 2396, non-ASCII characters are not allowed in headers,\n   // therefore we can just iterate over the string without casting it into []rune\n   i := 0\n   for ; i < len(accepted); i++ {\n    if accepted[i] == \'*\' || offer[i] == \'*\' {\n     return offer\n    }\n    if accepted[i] != offer[i] {\n     break\n    }\n   }\n   if i == len(accepted) {\n    return offer\n   }\n  }\n }\n return ""\n}\n\n// SetAccepted sets Accept header data.\nfunc (c *Context) SetAccepted(formats ...string) {\n c.Accepted = formats\n}\n\n/************************************/\n/***** GOLANG.ORG/X/NET/CONTEXT *****/\n/************************************/\n\n// Deadline always returns that there is no deadline (ok==false),\n// maybe you want to use Request.Context().Deadline() instead.\nfunc (c *Context) Deadline() (deadline time.Time, ok bool) {\n return\n}\n\n// Done always returns nil (chan which will wait forever),\n// if you want to abort your work when the connection was closed\n// you should use Request.Context().Done() instead.\nfunc (c *Context) Done() <-chan struct{} {\n return nil\n}\n\n// Err always returns nil, maybe you want to use Request.Context().Err() instead.\nfunc (c *Context) Err() error {\n return nil\n}\n\n// Value returns the value associated with this context for key, or nil\n// if no value is associated with key. Successive calls to Value with\n// the same key returns the same result.\nfunc (c *Context) Value(key interface{}) interface{} {\n if key == 0 {\n  return c.Request\n }\n if keyAsString, ok := key.(string); ok {\n  val, _ := c.Get(keyAsString)\n  return val\n }\n return nil\n}\n\n\n\n')))}h.isMDXComponent=!0}}]);